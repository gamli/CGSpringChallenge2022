/*
 * File generated by SourceCombiner.exe using 6 source files.
 * Created On: 24.04.2022 21:55:06
*/
using CGSpringChallenge2022;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
//*** SourceCombiner -> original file GameState.cs ***
namespace CGSpringChallenge2022
{
    public class GameState
    {
        private readonly int _lives1;
        private readonly int _lives2;
        private readonly int _mana1;
        private readonly int _mana2;
        private readonly Vector2 _base1;
        private readonly Vector2 _base2;
        private readonly List<Hero> _heroes1;
        private readonly List<Hero> _heroes2;
        private readonly List<Monster> _monsters;
        public GameState(
            int lives1,
            int lives2,
            int mana1,
            int mana2,
            Vector2 base1,
            Vector2 base2,
            List<Monster> monsters,
            List<Hero> heroes1,
            List<Hero> heroes2)
        {
            _lives1 = lives1;
            _lives2 = lives2;
            _base1 = base1;
            _base2 = base2;
            _monsters = monsters;
            _heroes1 = heroes1;
            _heroes2 = heroes2;
            _mana1 = mana1;
            _mana2 = mana2;
        }
        public int Lives(int player) => player == 1 ? _lives1 : _lives2;
        public int Mana(int player) => player == 1 ? _mana1 : _mana2;
        public Vector2 Base(int player) => player == 1 ? _base1 : _base2;
        public List<Hero> Heroes(int player) => player == 1 ? _heroes1 : _heroes2;
        public List<Monster> Monsters() => _monsters;
    }
}
//*** SourceCombiner -> original file Geometry.cs ***
namespace CGSpringChallenge2022
{
    public static class Geometry
    {
        public static Vector2? ClosestLineCircleIntersection(
            Vector2 circleCenter,
            float circleRadius,
            Vector2 lineStart,
            Vector2 lineEnd)
        {
            var intersectionCount =
                LineCircleIntersections(
                    circleCenter,
                    circleRadius,
                    lineStart,
                    lineEnd,
                    out var intersection1,
                    out var intersection2);
            return intersectionCount switch
            {
                1 => intersection1,
                2 => DistanceSqr(intersection1, lineStart) < DistanceSqr(intersection2, lineStart)
                         ? intersection1
                         : intersection2,
                _ => null
            };
        }
        public static int LineCircleIntersections(
            Vector2 circleCenter,
            float circleRadius,
            Vector2 lineStart,
            Vector2 lineEnd,
            out Vector2 intersection1,
            out Vector2 intersection2)
        {
            var dx = lineEnd.X - lineStart.X;
            var dy = lineEnd.Y - lineStart.Y;
            var A = dx * dx + dy * dy;
            var B = 2 * (dx * (lineStart.X - circleCenter.X) + dy * (lineStart.Y - circleCenter.Y));
            var C =
                (lineStart.X - circleCenter.X) * (lineStart.X - circleCenter.X) +
                (lineStart.Y - circleCenter.Y) * (lineStart.Y - circleCenter.Y) -
                circleRadius * circleRadius;
            var det = B * B - 4 * A * C;
            if (A <= 0.0000001 || det < 0)
            {
                // No real solutions.
                intersection1 = Vector2.Zero;
                intersection2 = Vector2.Zero;
                return 0;
            }
            if (det == 0)
            {
                // One solution.
                var t = -B / (2 * A);
                intersection1 = new Vector2(lineStart.X + t * dx, lineStart.Y + t * dy);
                intersection2 = Vector2.Zero;
                return 1;
            }
            else
            {
                // Two solutions.
                var t = (float)((-B + Math.Sqrt(det)) / (2 * A));
                intersection1 = new Vector2(lineStart.X + t * dx, lineStart.Y + t * dy);
                t = (float)((-B - Math.Sqrt(det)) / (2 * A));
                intersection2 = new Vector2(lineStart.X + t * dx, lineStart.Y + t * dy);
                return 2;
            }
        }
        public static double Distance(Vector2 p1, Vector2 p2) => Math.Sqrt(DistanceSqr(p1, p2));
        public static double DistanceSqr(Vector2 p1, Vector2 p2) => Math.Pow(p2.X - p1.X, 2) + Math.Pow(p2.Y - p1.Y, 2);
    }
}
//*** SourceCombiner -> original file Hero.cs ***
namespace CGSpringChallenge2022
{
    public class Hero
    {
        public Hero(int id, Vector2 position)
        {
            Id = id;
            Position = position;
        }
        public int Id { get; }
        public Vector2 Position { get; }
    }
}
//*** SourceCombiner -> original file InputParser.cs ***
namespace CGSpringChallenge2022
{
    public class InputParser
    {
        private readonly Vector2 _base1;
        private readonly Vector2 _base2;
        public InputParser()
        {
            var xy = ReadInts();
            _base1 = new Vector2(xy[0], xy[1]);
            _base2 = xy[0] == 0 ? new Vector2(17630, 9000) : new Vector2(0, 0);
            Console.ReadLine(); // read number of heroes always 3... discard
        }
        public GameState Parse()
        {
            var healthMana1 = ReadInts();
            var healthMana2 = ReadInts();
            var monsters = new List<Monster>();
            var heroes1 = new List<Hero>();
            var heroes2 = new List<Hero>();
            var entityCount = int.Parse(Console.ReadLine()!);
            for (var i = 0; i < entityCount; i++)
            {
                var entityData = ReadInts();
                var id = entityData[0]; // Unique identifier
                var type = entityData[1]; // 0=monster, 1=your hero, 2=opponent hero
                var x = entityData[2]; // Position of this entity
                var y = entityData[3];
                var shieldLife = entityData[4]; // Ignore for this league; Count down until shield spell fades
                var isControlled = entityData[5]; // Ignore for this league; Equals 1 when this entity is under a control spell
                var health = entityData[6]; // Remaining health of this monster
                var vx = entityData[7]; // Trajectory of this monster
                var vy = entityData[8];
                var nearBase = entityData[9]; // 0=monster with no target yet, 1=monster targeting a base
                var threatFor = entityData[10]; // Given this monster's trajectory, is it a threat to 1=your base, 2=your opponent's base, 0=neither
                if (type == 0)
                {
                    monsters.Add(
                        new Monster(
                            id,
                            new Vector2(x, y),
                            shieldLife,
                            isControlled == 1,
                            health,
                            new Vector2(vx, vy),
                            nearBase == 1,
                            threatFor));
                }
                else
                {
                    var heroes = type == 1 ? heroes1 : heroes2;
                    heroes.Add(new Hero(id, new Vector2(x, y)));
                }
            }
            return new GameState(
                healthMana1[0],
                healthMana2[0],
                healthMana1[1],
                healthMana2[1],
                _base1,
                _base2,
                monsters,
                heroes1,
                heroes2);
        }
        private int[] ReadInts() => Console.ReadLine()!.Split(' ').Select(int.Parse).ToArray();
    }
}
//*** SourceCombiner -> original file Monster.cs ***
namespace CGSpringChallenge2022
{
    public class Monster
    {
        public Monster(
            int id,
            Vector2 position,
            int shieldLife,
            bool isControlled,
            int health,
            Vector2 trajectory,
            bool targetingBase,
            int isThreatForPlayer)
        {
            Id = id;
            Position = position;
            ShieldLife = shieldLife;
            IsControlled = isControlled;
            Health = health;
            Trajectory = trajectory;
            TargetingBase = targetingBase;
            IsThreatForPlayer = isThreatForPlayer;
        }
        public int Id { get; }
        public Vector2 Position { get; }
        public int ShieldLife { get; }
        public bool IsControlled { get; }
        public int Health { get; }
        public Vector2 Trajectory { get; }
        public bool TargetingBase { get; }
        public int IsThreatForPlayer { get; }
    }
}
//*** SourceCombiner -> original file Player.cs ***
/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
public class Player
{
    public const int PLAYER_ME = 1;
    public const int PLAYER_OPPONENT = 2;
    static void Main(string[] args)
    {
        var inputParser = new InputParser();
        // game loop
        while (true)
        {
            var gameState = inputParser.Parse();
            var heroes = gameState.Heroes(PLAYER_ME);
            var threats =
                gameState.Monsters()
                         .Where(monster => monster.IsThreatForPlayer == PLAYER_ME)
                         .OrderBy(monster => Geometry.DistanceSqr(monster.Position, gameState.Base(PLAYER_ME)))
                         .Take(heroes.Count)
                         .ToList();
            var availableHeroes = new HashSet<Hero>(heroes);
            var orders = new List<(int, string)>();
            while (threats.Any() && availableHeroes.Any())
            {
                foreach (var monster in threats)
                {
                    if (!availableHeroes.Any())
                    {
                        break;
                    }
                    var nearestHero = availableHeroes.OrderBy(hero => Geometry.DistanceSqr(hero.Position, monster.Position)).First();
                    var heroIdx = heroes.IndexOf(nearestHero);
                    var order = "MOVE " + (int)monster.Position.X + " " + +(int)monster.Position.Y;
                    orders.Add((heroIdx, order));
                    availableHeroes.Remove(nearestHero);
                    Console.Error.WriteLine("Hero " + nearestHero.Id + " moving towards monster " + monster.Id);
                }
            }
            orders.AddRange(availableHeroes.Select(hero => (heroes.IndexOf(hero), "WAIT")));
            foreach (var order in orders.OrderBy(idxCommand => idxCommand.Item1).Select(idxCommand => idxCommand.Item2))
            {
                Console.WriteLine(order);
            }
        }
    }
}
